AWSTemplateFormatVersion: '2010-09-09'
Description: 'AWS Secrets Manager Integration with Application Examples and Automatic Rotation'

Parameters:
  DatabaseName:
    Type: String
    Description: Name of the database for secret storage
    Default: 'secrets-lab-db'
    
  DatabaseUsername:
    Type: String
    Description: Master username for the database
    Default: 'dbadmin'
    NoEcho: true
    
  DatabasePassword:
    Type: String
    Description: Master password for the database
    MinLength: 8
    MaxLength: 128
    NoEcho: true
    Default: 'TempPassword123!'
    
  ApplicationName:
    Type: String
    Description: Name of the application using secrets
    Default: 'secrets-lab-app'
    
  Environment:
    Type: String
    Description: Environment name (dev, staging, prod)
    Default: 'dev'
    AllowedValues: ['dev', 'staging', 'prod']

Resources:
  # VPC and Networking for RDS
  VPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: 10.0.0.0/16
      EnableDnsHostnames: true
      EnableDnsSupport: true
      Tags:
        - Key: Name
          Value: !Sub '${ApplicationName}-vpc'

  PrivateSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: 10.0.1.0/24
      AvailabilityZone: !Select [0, !GetAZs '']
      Tags:
        - Key: Name
          Value: !Sub '${ApplicationName}-private-subnet-1'

  PrivateSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: 10.0.2.0/24
      AvailabilityZone: !Select [1, !GetAZs '']
      Tags:
        - Key: Name
          Value: !Sub '${ApplicationName}-private-subnet-2'

  PublicSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: 10.0.101.0/24
      AvailabilityZone: !Select [0, !GetAZs '']
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: !Sub '${ApplicationName}-public-subnet-1'

  PublicSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: 10.0.102.0/24
      AvailabilityZone: !Select [1, !GetAZs '']
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: !Sub '${ApplicationName}-public-subnet-2'

  InternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
        - Key: Name
          Value: !Sub '${ApplicationName}-igw'

  AttachGateway:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref VPC
      InternetGatewayId: !Ref InternetGateway

  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub '${ApplicationName}-public-rt'

  PublicRoute:
    Type: AWS::EC2::Route
    DependsOn: AttachGateway
    Properties:
      RouteTableId: !Ref PublicRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway

  PublicSubnetRouteTableAssociation1:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnet1
      RouteTableId: !Ref PublicRouteTable

  PublicSubnetRouteTableAssociation2:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnet2
      RouteTableId: !Ref PublicRouteTable

  # Database Security Group
  DatabaseSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for RDS database
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 5432
          ToPort: 5432
          SourceSecurityGroupId: !Ref ApplicationSecurityGroup
        - IpProtocol: tcp
          FromPort: 5432
          ToPort: 5432
          SourceSecurityGroupId: !Ref LambdaSecurityGroup
      Tags:
        - Key: Name
          Value: !Sub '${ApplicationName}-db-sg'

  ApplicationSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for application instances
      VpcId: !Ref VPC
      SecurityGroupEgress:
        - IpProtocol: -1
          CidrIp: 0.0.0.0/0
      Tags:
        - Key: Name
          Value: !Sub '${ApplicationName}-app-sg'

  LambdaSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for Lambda functions
      VpcId: !Ref VPC
      SecurityGroupEgress:
        - IpProtocol: -1
          CidrIp: 0.0.0.0/0
      Tags:
        - Key: Name
          Value: !Sub '${ApplicationName}-lambda-sg'

  # RDS Subnet Group
  DatabaseSubnetGroup:
    Type: AWS::RDS::DBSubnetGroup
    Properties:
      DBSubnetGroupDescription: Subnet group for RDS database
      SubnetIds:
        - !Ref PrivateSubnet1
        - !Ref PrivateSubnet2
      Tags:
        - Key: Name
          Value: !Sub '${ApplicationName}-db-subnet-group'

  # RDS Database Instance
  Database:
    Type: AWS::RDS::DBInstance
    DeletionPolicy: Delete
    Properties:
      DBInstanceIdentifier: !Ref DatabaseName
      DBInstanceClass: db.t3.micro
      Engine: postgres
      EngineVersion: '13.13'
      MasterUsername: !Ref DatabaseUsername
      MasterUserPassword: !Ref DatabasePassword
      AllocatedStorage: 20
      StorageType: gp2
      DBSubnetGroupName: !Ref DatabaseSubnetGroup
      VPCSecurityGroups:
        - !Ref DatabaseSecurityGroup
      BackupRetentionPeriod: 7
      MultiAZ: false
      PubliclyAccessible: false
      StorageEncrypted: true
      DeletionProtection: false
      Tags:
        - Key: Name
          Value: !Sub '${ApplicationName}-database'

  # KMS Key for Secrets Encryption
  SecretsKMSKey:
    Type: AWS::KMS::Key
    Properties:
      Description: KMS key for encrypting secrets
      KeyPolicy:
        Version: '2012-10-17'
        Statement:
          - Sid: Enable IAM User Permissions
            Effect: Allow
            Principal:
              AWS: !Sub 'arn:aws:iam::${AWS::AccountId}:root'
            Action: 'kms:*'
            Resource: '*'
          - Sid: Allow Secrets Manager
            Effect: Allow
            Principal:
              Service: secretsmanager.amazonaws.com
            Action:
              - kms:Decrypt
              - kms:DescribeKey
              - kms:Encrypt
              - kms:GenerateDataKey*
              - kms:ReEncrypt*
            Resource: '*'

  SecretsKMSKeyAlias:
    Type: AWS::KMS::Alias
    Properties:
      AliasName: !Sub 'alias/${ApplicationName}-secrets-key'
      TargetKeyId: !Ref SecretsKMSKey

  # Database Credentials Secret
  DatabaseSecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: !Sub '${ApplicationName}/${Environment}/database/credentials'
      Description: Database credentials for the application
      KmsKeyId: !Ref SecretsKMSKey
      SecretString: !Sub |
        {
          "username": "${DatabaseUsername}",
          "password": "${DatabasePassword}",
          "engine": "postgres",
          "host": "${Database.Endpoint.Address}",
          "port": ${Database.Endpoint.Port},
          "dbname": "postgres",
          "dbInstanceIdentifier": "${Database}"
        }
      Tags:
        - Key: Application
          Value: !Ref ApplicationName
        - Key: Environment
          Value: !Ref Environment

  # API Keys Secret
  APIKeysSecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: !Sub '${ApplicationName}/${Environment}/api/keys'
      Description: API keys for external services
      KmsKeyId: !Ref SecretsKMSKey
      GenerateSecretString:
        SecretStringTemplate: '{"username": "api-user"}'
        GenerateStringKey: 'api-key'
        PasswordLength: 32
        ExcludeCharacters: '"@/\'
      Tags:
        - Key: Application
          Value: !Ref ApplicationName
        - Key: Environment
          Value: !Ref Environment

  # JWT Secret
  JWTSecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: !Sub '${ApplicationName}/${Environment}/jwt/secret'
      Description: JWT signing secret
      KmsKeyId: !Ref SecretsKMSKey
      GenerateSecretString:
        PasswordLength: 64
        ExcludeCharacters: '"@/\'
      Tags:
        - Key: Application
          Value: !Ref ApplicationName
        - Key: Environment
          Value: !Ref Environment

  # Lambda Execution Role for Rotation
  RotationLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${ApplicationName}-rotation-lambda-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
      Policies:
        - PolicyName: SecretsManagerRotationPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - secretsmanager:DescribeSecret
                  - secretsmanager:GetSecretValue
                  - secretsmanager:PutSecretValue
                  - secretsmanager:UpdateSecretVersionStage
                Resource: !Ref DatabaseSecret
              - Effect: Allow
                Action:
                  - kms:Decrypt
                  - kms:DescribeKey
                  - kms:Encrypt
                  - kms:GenerateDataKey*
                  - kms:ReEncrypt*
                Resource: !GetAtt SecretsKMSKey.Arn
              - Effect: Allow
                Action:
                  - rds:ModifyDBInstance
                  - rds:DescribeDBInstances
                Resource: !Sub 'arn:aws:rds:${AWS::Region}:${AWS::AccountId}:db:${Database}'

  # Lambda Function for Secret Rotation
  RotationLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${ApplicationName}-secrets-rotation'
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt RotationLambdaRole.Arn
      Timeout: 300
      VpcConfig:
        SecurityGroupIds:
          - !Ref LambdaSecurityGroup
        SubnetIds:
          - !Ref PrivateSubnet1
          - !Ref PrivateSubnet2
      Environment:
        Variables:
          SECRETS_MANAGER_ENDPOINT: !Sub 'https://secretsmanager.${AWS::Region}.amazonaws.com'
      Code:
        ZipFile: |
          import json
          import boto3
          import logging
          import os
          import psycopg2
          import random
          import string
          from botocore.exceptions import ClientError

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def lambda_handler(event, context):
              """AWS Secrets Manager rotation function for PostgreSQL"""
              
              service = boto3.client('secretsmanager')
              
              # Get the secret ARN and token from the event
              secret_arn = event['SecretId']
              token = event['ClientRequestToken']
              step = event['Step']
              
              logger.info(f"Rotation step: {step} for secret: {secret_arn}")
              
              try:
                  if step == "createSecret":
                      create_secret(service, secret_arn, token)
                  elif step == "setSecret":
                      set_secret(service, secret_arn, token)
                  elif step == "testSecret":
                      test_secret(service, secret_arn, token)
                  elif step == "finishSecret":
                      finish_secret(service, secret_arn, token)
                  else:
                      logger.error(f"Invalid step parameter: {step}")
                      raise ValueError(f"Invalid step parameter: {step}")
                      
              except Exception as e:
                  logger.error(f"Rotation failed: {str(e)}")
                  raise e
              
              return {"statusCode": 200}

          def create_secret(service, secret_arn, token):
              """Generate a new secret version with a new password"""
              try:
                  service.get_secret_value(SecretId=secret_arn, VersionId=token, VersionStage="AWSPENDING")
                  logger.info("Secret version already exists")
              except ClientError:
                  # Generate new password
                  current_secret = service.get_secret_value(SecretId=secret_arn, VersionStage="AWSCURRENT")
                  secret_dict = json.loads(current_secret['SecretString'])
                  
                  # Generate new password
                  new_password = generate_password()
                  secret_dict['password'] = new_password
                  
                  service.put_secret_value(
                      SecretId=secret_arn,
                      ClientRequestToken=token,
                      SecretString=json.dumps(secret_dict),
                      VersionStages=['AWSPENDING']
                  )
                  logger.info("New secret version created")

          def set_secret(service, secret_arn, token):
              """Update the database with the new password"""
              try:
                  # Get both current and pending secrets
                  current_secret = service.get_secret_value(SecretId=secret_arn, VersionStage="AWSCURRENT")
                  pending_secret = service.get_secret_value(SecretId=secret_arn, VersionId=token, VersionStage="AWSPENDING")
                  
                  current_dict = json.loads(current_secret['SecretString'])
                  pending_dict = json.loads(pending_secret['SecretString'])
                  
                  # Connect to database with current credentials and update password
                  conn = psycopg2.connect(
                      host=current_dict['host'],
                      port=current_dict['port'],
                      database=current_dict['dbname'],
                      user=current_dict['username'],
                      password=current_dict['password']
                  )
                  
                  with conn.cursor() as cursor:
                      cursor.execute(f"ALTER USER {current_dict['username']} PASSWORD %s", (pending_dict['password'],))
                  
                  conn.commit()
                  conn.close()
                  logger.info("Password updated in database")
                  
              except Exception as e:
                  logger.error(f"Failed to set secret: {str(e)}")
                  raise

          def test_secret(service, secret_arn, token):
              """Test the new secret by connecting to the database"""
              try:
                  pending_secret = service.get_secret_value(SecretId=secret_arn, VersionId=token, VersionStage="AWSPENDING")
                  pending_dict = json.loads(pending_secret['SecretString'])
                  
                  # Test connection with new password
                  conn = psycopg2.connect(
                      host=pending_dict['host'],
                      port=pending_dict['port'],
                      database=pending_dict['dbname'],
                      user=pending_dict['username'],
                      password=pending_dict['password']
                  )
                  
                  conn.close()
                  logger.info("New secret tested successfully")
                  
              except Exception as e:
                  logger.error(f"Failed to test secret: {str(e)}")
                  raise

          def finish_secret(service, secret_arn, token):
              """Finalize the rotation by updating the AWSCURRENT version"""
              try:
                  # Get current version ID
                  metadata = service.describe_secret(SecretId=secret_arn)
                  current_version = None
                  
                  for version_id, stages in metadata['VersionIdsToStages'].items():
                      if 'AWSCURRENT' in stages:
                          current_version = version_id
                          break
                  
                  # Update version stages
                  service.update_secret_version_stage(
                      SecretId=secret_arn,
                      VersionStage="AWSCURRENT",
                      ClientRequestToken=token,
                      RemoveFromVersionId=current_version
                  )
                  
                  logger.info("Rotation completed successfully")
                  
              except Exception as e:
                  logger.error(f"Failed to finish rotation: {str(e)}")
                  raise

          def generate_password(length=16):
              """Generate a random password"""
              characters = string.ascii_letters + string.digits + "!@#$%^&*"
              return ''.join(random.choice(characters) for _ in range(length))

  # Lambda Permission for Secrets Manager
  RotationLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref RotationLambdaFunction
      Action: lambda:InvokeFunction
      Principal: secretsmanager.amazonaws.com

  # Secret Rotation Configuration
  DatabaseSecretRotation:
    Type: AWS::SecretsManager::RotationSchedule
    Properties:
      SecretId: !Ref DatabaseSecret
      RotationLambdaArn: !GetAtt RotationLambdaFunction.Arn
      RotationRules:
        AutomaticallyAfterDays: 30

  # Application Role for Secret Access
  ApplicationRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${ApplicationName}-application-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: 
                - ecs-tasks.amazonaws.com
                - lambda.amazonaws.com
                - ec2.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: SecretsAccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                  - secretsmanager:DescribeSecret
                Resource:
                  - !Ref DatabaseSecret
                  - !Ref APIKeysSecret
                  - !Ref JWTSecret
              - Effect: Allow
                Action:
                  - kms:Decrypt
                  - kms:DescribeKey
                Resource: !GetAtt SecretsKMSKey.Arn

  # CloudWatch Log Group for Application
  ApplicationLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/application/${ApplicationName}'
      RetentionInDays: 14

  # CloudWatch Alarms for Secret Access Monitoring
  SecretAccessAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub '${ApplicationName}-secret-access-failures'
      AlarmDescription: Monitor failed secret access attempts
      MetricName: SecretAccessFailures
      Namespace: !Sub '${ApplicationName}/Secrets'
      Statistic: Sum
      Period: 300
      EvaluationPeriods: 1
      Threshold: 5
      ComparisonOperator: GreaterThanThreshold
      TreatMissingData: notBreaching

  # SNS Topic for Alerts
  AlertsTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: !Sub '${ApplicationName}-secrets-alerts'
      DisplayName: Secrets Management Alerts

Outputs:
  DatabaseSecretArn:
    Description: ARN of the database credentials secret
    Value: !Ref DatabaseSecret
    Export:
      Name: !Sub '${AWS::StackName}-DatabaseSecretArn'

  APIKeysSecretArn:
    Description: ARN of the API keys secret
    Value: !Ref APIKeysSecret
    Export:
      Name: !Sub '${AWS::StackName}-APIKeysSecretArn'

  JWTSecretArn:
    Description: ARN of the JWT secret
    Value: !Ref JWTSecret
    Export:
      Name: !Sub '${AWS::StackName}-JWTSecretArn'

  ApplicationRoleArn:
    Description: ARN of the application role for secret access
    Value: !GetAtt ApplicationRole.Arn
    Export:
      Name: !Sub '${AWS::StackName}-ApplicationRoleArn'

  DatabaseEndpoint:
    Description: RDS database endpoint
    Value: !GetAtt Database.Endpoint.Address
    Export:
      Name: !Sub '${AWS::StackName}-DatabaseEndpoint'

  VPCId:
    Description: VPC ID for the application
    Value: !Ref VPC
    Export:
      Name: !Sub '${AWS::StackName}-VPCId'

  PrivateSubnetIds:
    Description: Private subnet IDs
    Value: !Sub '${PrivateSubnet1},${PrivateSubnet2}'
    Export:
      Name: !Sub '${AWS::StackName}-PrivateSubnetIds'

  PublicSubnetIds:
    Description: Public subnet IDs
    Value: !Sub '${PublicSubnet1},${PublicSubnet2}'
    Export:
      Name: !Sub '${AWS::StackName}-PublicSubnetIds'

  ApplicationSecurityGroupId:
    Description: Security group ID for applications
    Value: !Ref ApplicationSecurityGroup
    Export:
      Name: !Sub '${AWS::StackName}-ApplicationSecurityGroupId'

  SecretsRetrievalCommands:
    Description: Commands to retrieve secrets
    Value: !Sub |
      # Database credentials:
      aws secretsmanager get-secret-value --secret-id ${DatabaseSecret} --query SecretString --output text

      # API keys:
      aws secretsmanager get-secret-value --secret-id ${APIKeysSecret} --query SecretString --output text

      # JWT secret:
      aws secretsmanager get-secret-value --secret-id ${JWTSecret} --query SecretString --output text

  RotationStatus:
    Description: Database secret rotation configuration
    Value: !Sub 'Automatic rotation enabled every 30 days using Lambda function: ${RotationLambdaFunction}'