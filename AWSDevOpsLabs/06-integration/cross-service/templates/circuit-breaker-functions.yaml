AWSTemplateFormatVersion: '2010-09-09'
Description: 'Circuit breaker Lambda functions for distributed system resilience'

Parameters:
  VpcId:
    Type: AWS::EC2::VPC::Id
    Description: VPC ID for Lambda functions
  
  PrivateSubnetIds:
    Type: List<AWS::EC2::Subnet::Id>
    Description: Private subnet IDs for Lambda functions

Resources:
  # Circuit Breaker State Table
  CircuitBreakerStateTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: circuit-breaker-state
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: service_name
          AttributeType: S
      KeySchema:
        - AttributeName: service_name
          KeyType: HASH
      TimeToLiveSpecification:
        AttributeName: ttl
        Enabled: true
      StreamSpecification:
        StreamViewType: NEW_AND_OLD_IMAGES

  # Lambda Execution Role
  CircuitBreakerLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: CircuitBreakerLambdaRole
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
      Policies:
        - PolicyName: CircuitBreakerPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                  - dynamodb:DeleteItem
                  - dynamodb:Query
                  - dynamodb:Scan
                Resource: !GetAtt CircuitBreakerStateTable.Arn
              - Effect: Allow
                Action:
                  - cloudwatch:PutMetricData
                  - cloudwatch:GetMetricStatistics
                Resource: '*'
              - Effect: Allow
                Action:
                  - xray:PutTraceSegments
                  - xray:PutTelemetryRecords
                Resource: '*'
              - Effect: Allow
                Action:
                  - ec2:CreateNetworkInterface
                  - ec2:DescribeNetworkInterfaces
                  - ec2:DeleteNetworkInterface
                Resource: '*'

  # Security Group for Lambda Functions
  CircuitBreakerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for circuit breaker Lambda functions
      VpcId: !Ref VpcId
      SecurityGroupEgress:
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
          Description: HTTPS outbound
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0
          Description: HTTP outbound
        - IpProtocol: tcp
          FromPort: 8080
          ToPort: 8080
          CidrIp: 10.0.0.0/8
          Description: Service communication

  # Circuit Breaker Manager Function
  CircuitBreakerManagerFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: circuit-breaker-manager
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt CircuitBreakerLambdaRole.Arn
      Timeout: 30
      MemorySize: 256
      VpcConfig:
        SecurityGroupIds:
          - !Ref CircuitBreakerSecurityGroup
        SubnetIds: !Ref PrivateSubnetIds
      Environment:
        Variables:
          CIRCUIT_BREAKER_TABLE: !Ref CircuitBreakerStateTable
          FAILURE_THRESHOLD: '5'
          SUCCESS_THRESHOLD: '3'
          TIMEOUT_SECONDS: '60'
      TracingConfig:
        Mode: Active
      Code:
        ZipFile: |
          import json
          import boto3
          import time
          import os
          from decimal import Decimal
          from enum import Enum
          
          dynamodb = boto3.resource('dynamodb')
          cloudwatch = boto3.client('cloudwatch')
          
          class CircuitState(Enum):
              CLOSED = "CLOSED"
              OPEN = "OPEN"
              HALF_OPEN = "HALF_OPEN"
          
          def lambda_handler(event, context):
              table_name = os.environ['CIRCUIT_BREAKER_TABLE']
              table = dynamodb.Table(table_name)
              
              service_name = event.get('service_name')
              action = event.get('action', 'check')
              success = event.get('success', True)
              
              if not service_name:
                  return {
                      'statusCode': 400,
                      'body': json.dumps({'error': 'service_name is required'})
                  }
              
              try:
                  if action == 'check':
                      return check_circuit_state(table, service_name)
                  elif action == 'record':
                      return record_call_result(table, service_name, success)
                  elif action == 'reset':
                      return reset_circuit(table, service_name)
                  else:
                      return {
                          'statusCode': 400,
                          'body': json.dumps({'error': 'Invalid action'})
                      }
              except Exception as e:
                  return {
                      'statusCode': 500,
                      'body': json.dumps({'error': str(e)})
                  }
          
          def check_circuit_state(table, service_name):
              try:
                  response = table.get_item(Key={'service_name': service_name})
                  
                  if 'Item' not in response:
                      # Initialize circuit breaker for new service
                      initialize_circuit(table, service_name)
                      return {
                          'statusCode': 200,
                          'body': json.dumps({
                              'service_name': service_name,
                              'state': CircuitState.CLOSED.value,
                              'allow_request': True
                          })
                      }
                  
                  item = response['Item']
                  current_state = item['state']
                  failure_count = item.get('failure_count', 0)
                  success_count = item.get('success_count', 0)
                  last_failure_time = item.get('last_failure_time', 0)
                  
                  failure_threshold = int(os.environ.get('FAILURE_THRESHOLD', 5))
                  success_threshold = int(os.environ.get('SUCCESS_THRESHOLD', 3))
                  timeout_seconds = int(os.environ.get('TIMEOUT_SECONDS', 60))
                  
                  current_time = int(time.time())
                  allow_request = True
                  
                  if current_state == CircuitState.OPEN.value:
                      if current_time - last_failure_time > timeout_seconds:
                          # Transition to HALF_OPEN
                          update_circuit_state(table, service_name, CircuitState.HALF_OPEN.value)
                          current_state = CircuitState.HALF_OPEN.value
                      else:
                          allow_request = False
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps({
                          'service_name': service_name,
                          'state': current_state,
                          'allow_request': allow_request,
                          'failure_count': failure_count,
                          'success_count': success_count
                      })
                  }
              except Exception as e:
                  raise e
          
          def record_call_result(table, service_name, success):
              try:
                  response = table.get_item(Key={'service_name': service_name})
                  
                  if 'Item' not in response:
                      initialize_circuit(table, service_name)
                      response = table.get_item(Key={'service_name': service_name})
                  
                  item = response['Item']
                  current_state = item['state']
                  failure_count = item.get('failure_count', 0)
                  success_count = item.get('success_count', 0)
                  
                  failure_threshold = int(os.environ.get('FAILURE_THRESHOLD', 5))
                  success_threshold = int(os.environ.get('SUCCESS_THRESHOLD', 3))
                  
                  if success:
                      success_count += 1
                      failure_count = 0  # Reset failure count on success
                      
                      if current_state == CircuitState.HALF_OPEN.value and success_count >= success_threshold:
                          # Transition to CLOSED
                          update_circuit_state(table, service_name, CircuitState.CLOSED.value, 0, 0)
                          current_state = CircuitState.CLOSED.value
                      else:
                          update_circuit_counts(table, service_name, failure_count, success_count)
                  else:
                      failure_count += 1
                      success_count = 0  # Reset success count on failure
                      
                      if failure_count >= failure_threshold:
                          # Transition to OPEN
                          update_circuit_state(table, service_name, CircuitState.OPEN.value, failure_count, success_count, int(time.time()))
                          current_state = CircuitState.OPEN.value
                      else:
                          update_circuit_counts(table, service_name, failure_count, success_count)
                  
                  # Send metrics to CloudWatch
                  send_metrics(service_name, current_state, failure_count, success_count)
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps({
                          'service_name': service_name,
                          'state': current_state,
                          'failure_count': failure_count,
                          'success_count': success_count,
                          'result_recorded': True
                      })
                  }
              except Exception as e:
                  raise e
          
          def initialize_circuit(table, service_name):
              table.put_item(
                  Item={
                      'service_name': service_name,
                      'state': CircuitState.CLOSED.value,
                      'failure_count': 0,
                      'success_count': 0,
                      'last_failure_time': 0,
                      'created_at': int(time.time()),
                      'ttl': int(time.time()) + 86400  # 24 hours TTL
                  }
              )
          
          def update_circuit_state(table, service_name, state, failure_count=None, success_count=None, last_failure_time=None):
              update_expression = "SET #state = :state, updated_at = :updated_at"
              expression_values = {
                  ':state': state,
                  ':updated_at': int(time.time())
              }
              expression_names = {'#state': 'state'}
              
              if failure_count is not None:
                  update_expression += ", failure_count = :failure_count"
                  expression_values[':failure_count'] = failure_count
              
              if success_count is not None:
                  update_expression += ", success_count = :success_count"
                  expression_values[':success_count'] = success_count
              
              if last_failure_time is not None:
                  update_expression += ", last_failure_time = :last_failure_time"
                  expression_values[':last_failure_time'] = last_failure_time
              
              table.update_item(
                  Key={'service_name': service_name},
                  UpdateExpression=update_expression,
                  ExpressionAttributeNames=expression_names,
                  ExpressionAttributeValues=expression_values
              )
          
          def update_circuit_counts(table, service_name, failure_count, success_count):
              table.update_item(
                  Key={'service_name': service_name},
                  UpdateExpression="SET failure_count = :failure_count, success_count = :success_count, updated_at = :updated_at",
                  ExpressionAttributeValues={
                      ':failure_count': failure_count,
                      ':success_count': success_count,
                      ':updated_at': int(time.time())
                  }
              )
          
          def reset_circuit(table, service_name):
              table.update_item(
                  Key={'service_name': service_name},
                  UpdateExpression="SET #state = :state, failure_count = :zero, success_count = :zero, updated_at = :updated_at",
                  ExpressionAttributeNames={'#state': 'state'},
                  ExpressionAttributeValues={
                      ':state': CircuitState.CLOSED.value,
                      ':zero': 0,
                      ':updated_at': int(time.time())
                  }
              )
              
              return {
                  'statusCode': 200,
                  'body': json.dumps({
                      'service_name': service_name,
                      'state': CircuitState.CLOSED.value,
                      'reset': True
                  })
              }
          
          def send_metrics(service_name, state, failure_count, success_count):
              try:
                  cloudwatch.put_metric_data(
                      Namespace='CircuitBreaker',
                      MetricData=[
                          {
                              'MetricName': 'FailureCount',
                              'Dimensions': [
                                  {
                                      'Name': 'ServiceName',
                                      'Value': service_name
                                  }
                              ],
                              'Value': failure_count,
                              'Unit': 'Count'
                          },
                          {
                              'MetricName': 'SuccessCount',
                              'Dimensions': [
                                  {
                                      'Name': 'ServiceName',
                                      'Value': service_name
                                  }
                              ],
                              'Value': success_count,
                              'Unit': 'Count'
                          },
                          {
                              'MetricName': 'CircuitState',
                              'Dimensions': [
                                  {
                                      'Name': 'ServiceName',
                                      'Value': service_name
                                  }
                              ],
                              'Value': 1 if state == CircuitState.OPEN.value else 0,
                              'Unit': 'Count'
                          }
                      ]
                  )
              except Exception as e:
                  print(f"Failed to send metrics: {str(e)}")

  # Health Check Function
  HealthCheckFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: service-health-checker
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt CircuitBreakerLambdaRole.Arn
      Timeout: 30
      MemorySize: 256
      VpcConfig:
        SecurityGroupIds:
          - !Ref CircuitBreakerSecurityGroup
        SubnetIds: !Ref PrivateSubnetIds
      Environment:
        Variables:
          CIRCUIT_BREAKER_FUNCTION: !Ref CircuitBreakerManagerFunction
      TracingConfig:
        Mode: Active
      Code:
        ZipFile: |
          import json
          import boto3
          import urllib3
          import time
          import os
          
          lambda_client = boto3.client('lambda')
          http = urllib3.PoolManager()
          
          def lambda_handler(event, context):
              services = event.get('services', [])
              results = []
              
              for service in services:
                  service_name = service.get('name')
                  health_endpoint = service.get('health_endpoint')
                  timeout = service.get('timeout', 5)
                  
                  if not service_name or not health_endpoint:
                      continue
                  
                  try:
                      start_time = time.time()
                      response = http.request('GET', health_endpoint, timeout=timeout)
                      response_time = time.time() - start_time
                      
                      is_healthy = response.status == 200
                      
                      # Record result with circuit breaker
                      record_result(service_name, is_healthy)
                      
                      results.append({
                          'service_name': service_name,
                          'healthy': is_healthy,
                          'response_time': response_time,
                          'status_code': response.status
                      })
                      
                  except Exception as e:
                      # Record failure with circuit breaker
                      record_result(service_name, False)
                      
                      results.append({
                          'service_name': service_name,
                          'healthy': False,
                          'error': str(e)
                      })
              
              return {
                  'statusCode': 200,
                  'body': json.dumps({
                      'timestamp': int(time.time()),
                      'results': results
                  })
              }
          
          def record_result(service_name, success):
              try:
                  circuit_breaker_function = os.environ['CIRCUIT_BREAKER_FUNCTION']
                  
                  payload = {
                      'service_name': service_name,
                      'action': 'record',
                      'success': success
                  }
                  
                  lambda_client.invoke(
                      FunctionName=circuit_breaker_function,
                      InvocationType='Event',
                      Payload=json.dumps(payload)
                  )
              except Exception as e:
                  print(f"Failed to record result for {service_name}: {str(e)}")

  # EventBridge Rule for Periodic Health Checks
  HealthCheckScheduleRule:
    Type: AWS::Events::Rule
    Properties:
      Name: service-health-check-schedule
      Description: Periodic health check for services
      ScheduleExpression: rate(1 minute)
      State: ENABLED
      Targets:
        - Arn: !GetAtt HealthCheckFunction.Arn
          Id: HealthCheckTarget
          Input: !Sub |
            {
              "services": [
                {
                  "name": "user-service",
                  "health_endpoint": "http://user-service.cross-service.local:8080/health",
                  "timeout": 5
                },
                {
                  "name": "order-service",
                  "health_endpoint": "http://order-service.cross-service.local:8080/health",
                  "timeout": 5
                },
                {
                  "name": "inventory-service",
                  "health_endpoint": "http://inventory-service.cross-service.local:8080/health",
                  "timeout": 5
                },
                {
                  "name": "notification-service",
                  "health_endpoint": "http://notification-service.cross-service.local:8080/health",
                  "timeout": 5
                }
              ]
            }

  # Permission for EventBridge to invoke Lambda
  HealthCheckLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref HealthCheckFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt HealthCheckScheduleRule.Arn

  # CloudWatch Dashboard
  CircuitBreakerDashboard:
    Type: AWS::CloudWatch::Dashboard
    Properties:
      DashboardName: CircuitBreakerMonitoring
      DashboardBody: !Sub |
        {
          "widgets": [
            {
              "type": "metric",
              "x": 0,
              "y": 0,
              "width": 12,
              "height": 6,
              "properties": {
                "metrics": [
                  [ "CircuitBreaker", "FailureCount", "ServiceName", "user-service" ],
                  [ ".", ".", ".", "order-service" ],
                  [ ".", ".", ".", "inventory-service" ],
                  [ ".", ".", ".", "notification-service" ]
                ],
                "period": 300,
                "stat": "Sum",
                "region": "${AWS::Region}",
                "title": "Service Failure Counts"
              }
            },
            {
              "type": "metric",
              "x": 12,
              "y": 0,
              "width": 12,
              "height": 6,
              "properties": {
                "metrics": [
                  [ "CircuitBreaker", "CircuitState", "ServiceName", "user-service" ],
                  [ ".", ".", ".", "order-service" ],
                  [ ".", ".", ".", "inventory-service" ],
                  [ ".", ".", ".", "notification-service" ]
                ],
                "period": 300,
                "stat": "Maximum",
                "region": "${AWS::Region}",
                "title": "Circuit Breaker States (1=Open, 0=Closed/Half-Open)"
              }
            }
          ]
        }

Outputs:
  CircuitBreakerManagerFunctionArn:
    Description: ARN of the Circuit Breaker Manager Lambda function
    Value: !GetAtt CircuitBreakerManagerFunction.Arn
    Export:
      Name: !Sub ${AWS::StackName}-CircuitBreakerManagerArn

  HealthCheckFunctionArn:
    Description: ARN of the Health Check Lambda function
    Value: !GetAtt HealthCheckFunction.Arn
    Export:
      Name: !Sub ${AWS::StackName}-HealthCheckFunctionArn

  CircuitBreakerStateTableName:
    Description: Name of the Circuit Breaker State DynamoDB table
    Value: !Ref CircuitBreakerStateTable
    Export:
      Name: !Sub ${AWS::StackName}-CircuitBreakerTableName

  CircuitBreakerDashboardUrl:
    Description: URL of the Circuit Breaker CloudWatch Dashboard
    Value: !Sub https://console.aws.amazon.com/cloudwatch/home?region=${AWS::Region}#dashboards:name=${CircuitBreakerDashboard}
    Export:
      Name: !Sub ${AWS::StackName}-DashboardUrl