AWSTemplateFormatVersion: '2010-09-09'
Description: 'CloudWatch Log Aggregation Configuration for Multiple AWS Services'

Parameters:
  Environment:
    Type: String
    Default: Dev
    AllowedValues:
      - Dev
      - Test
      - Prod
    Description: Environment name for resource tagging
  
  RetentionDays:
    Type: Number
    Default: 14
    AllowedValues: [1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180, 365, 400, 545, 731, 1827, 3653]
    Description: Number of days to retain logs
  
  CreateDashboard:
    Type: String
    Default: 'true'
    AllowedValues:
      - 'true'
      - 'false'
    Description: Whether to create a logs dashboard

Resources:
  # IAM Role for CloudWatch Logs
  CloudWatchLogsRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: CloudWatchLogsPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                  - logs:DescribeLogStreams
                Resource: 
                  - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/centralized/${Environment}:*"
              - Effect: Allow
                Action:
                  - sqs:SendMessage
                Resource: !GetAtt LogProcessorDLQ.Arn
      Tags:
        - Key: Environment
          Value: !Ref Environment

  # Log Groups for Different Services
  LambdaLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/aws/lambda/${Environment}"
      RetentionInDays: !Ref RetentionDays
      Tags:
        - Key: Environment
          Value: !Ref Environment

  APIGatewayLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/aws/apigateway/${Environment}"
      RetentionInDays: !Ref RetentionDays
      Tags:
        - Key: Environment
          Value: !Ref Environment

  EC2LogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/aws/ec2/${Environment}"
      RetentionInDays: !Ref RetentionDays
      Tags:
        - Key: Environment
          Value: !Ref Environment

  ECSLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/aws/ecs/${Environment}"
      RetentionInDays: !Ref RetentionDays
      Tags:
        - Key: Environment
          Value: !Ref Environment

  RDSLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/aws/rds/${Environment}"
      RetentionInDays: !Ref RetentionDays
      Tags:
        - Key: Environment
          Value: !Ref Environment

  # Log Metric Filters
  ErrorMetricFilter:
    Type: AWS::Logs::MetricFilter
    Properties:
      LogGroupName: !Ref LambdaLogGroup
      FilterPattern: "ERROR"
      MetricTransformations:
        - MetricName: LambdaErrors
          MetricNamespace: !Sub "LogMetrics/${Environment}"
          MetricValue: "1"

  APIGateway4xxMetricFilter:
    Type: AWS::Logs::MetricFilter
    Properties:
      LogGroupName: !Ref APIGatewayLogGroup
      FilterPattern: "{ $.status >= 400 && $.status < 500 }"
      MetricTransformations:
        - MetricName: API4xxErrors
          MetricNamespace: !Sub "LogMetrics/${Environment}"
          MetricValue: "1"

  APIGateway5xxMetricFilter:
    Type: AWS::Logs::MetricFilter
    Properties:
      LogGroupName: !Ref APIGatewayLogGroup
      FilterPattern: "{ $.status >= 500 }"
      MetricTransformations:
        - MetricName: API5xxErrors
          MetricNamespace: !Sub "LogMetrics/${Environment}"
          MetricValue: "1"

  # Log Subscription Filter for Centralized Logging
  CentralizedLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/aws/centralized/${Environment}"
      RetentionInDays: !Ref RetentionDays
      Tags:
        - Key: Environment
          Value: !Ref Environment

  # Dead Letter Queue for failed log processing
  LogProcessorDLQ:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !Sub "${Environment}-log-processor-dlq"
      MessageRetentionPeriod: 1209600  # 14 days
      Tags:
        - Key: Environment
          Value: !Ref Environment

  # Lambda Function for Log Processing
  LogProcessorFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${Environment}-log-processor"
      Handler: index.handler
      Role: !GetAtt CloudWatchLogsRole.Arn
      Runtime: nodejs18.x
      Timeout: 60
      MemorySize: 256
      DeadLetterConfig:
        TargetArn: !GetAtt LogProcessorDLQ.Arn
      Environment:
        Variables:
          DESTINATION_LOG_GROUP: !Ref CentralizedLogGroup
          ENVIRONMENT: !Ref Environment
      Code:
        ZipFile: |
          const zlib = require('zlib');
          // Use AWS SDK v2 which is available in Lambda runtime
          const AWS = require('aws-sdk');
          const cloudwatchlogs = new AWS.CloudWatchLogs();
          
          exports.handler = async (event, context) => {
              try {
                  console.log('Processing log event:', JSON.stringify(event, null, 2));
                  
                  // Decode and decompress the log data
                  const payload = Buffer.from(event.awslogs.data, 'base64');
                  const decompressed = zlib.gunzipSync(payload).toString('utf8');
                  const logData = JSON.parse(decompressed);
                  
                  console.log('Decompressed log data:', JSON.stringify(logData, null, 2));
                  
                  // Process and enrich log events
                  const logEvents = logData.logEvents.map(logEvent => {
                      let parsedMessage;
                      try {
                          parsedMessage = JSON.parse(logEvent.message);
                      } catch (e) {
                          parsedMessage = { rawMessage: logEvent.message };
                      }
                      
                      return {
                          timestamp: logEvent.timestamp,
                          message: JSON.stringify({
                              ...parsedMessage,
                              sourceLogGroup: logData.logGroup,
                              sourceLogStream: logData.logStream,
                              environment: process.env.ENVIRONMENT,
                              enhancedTimestamp: new Date(logEvent.timestamp).toISOString(),
                              processedAt: new Date().toISOString()
                          })
                      };
                  });
                  
                  // Write to centralized log group
                  if (logEvents.length > 0) {
                      const logStreamName = `${logData.logGroup.replace(/[\/\:]/g, '-')}-${Date.now()}`;
                      
                      try {
                          // Create log stream
                          await cloudwatchlogs.createLogStream({
                              logGroupName: process.env.DESTINATION_LOG_GROUP,
                              logStreamName: logStreamName
                          }).promise();
                          console.log(`Created log stream: ${logStreamName}`);
                      } catch (error) {
                          if (error.code !== 'ResourceAlreadyExistsException') {
                              console.error('Error creating log stream:', error);
                              throw error;
                          }
                      }
                      
                      // Put log events
                      await cloudwatchlogs.putLogEvents({
                          logGroupName: process.env.DESTINATION_LOG_GROUP,
                          logStreamName: logStreamName,
                          logEvents: logEvents
                      }).promise();
                      
                      console.log(`Successfully processed ${logEvents.length} log events`);
                      return { 
                          statusCode: 200,
                          body: JSON.stringify({ 
                              status: 'success', 
                              processed: logEvents.length,
                              logStreamName: logStreamName
                          })
                      };
                  }
                  
                  return { 
                      statusCode: 200,
                      body: JSON.stringify({ status: 'success', processed: 0 })
                  };
              } catch (error) {
                  console.error('Error processing logs:', error);
                  return {
                      statusCode: 500,
                      body: JSON.stringify({ 
                          status: 'error', 
                          message: error.message 
                      })
                  };
              }
          };
      Tags:
        - Key: Environment
          Value: !Ref Environment

  # Permission for Lambda to be invoked by CloudWatch Logs
  LambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref LogProcessorFunction
      Principal: logs.amazonaws.com
      SourceArn: !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:*"

  # Log Subscription Filters to send logs to the centralized processor
  LambdaLogSubscription:
    Type: AWS::Logs::SubscriptionFilter
    DependsOn: LambdaPermission
    Properties:
      LogGroupName: !Ref LambdaLogGroup
      FilterPattern: ""
      DestinationArn: !GetAtt LogProcessorFunction.Arn

  APIGatewayLogSubscription:
    Type: AWS::Logs::SubscriptionFilter
    DependsOn: LambdaPermission
    Properties:
      LogGroupName: !Ref APIGatewayLogGroup
      FilterPattern: ""
      DestinationArn: !GetAtt LogProcessorFunction.Arn

  EC2LogSubscription:
    Type: AWS::Logs::SubscriptionFilter
    DependsOn: LambdaPermission
    Properties:
      LogGroupName: !Ref EC2LogGroup
      FilterPattern: ""
      DestinationArn: !GetAtt LogProcessorFunction.Arn

  ECSLogSubscription:
    Type: AWS::Logs::SubscriptionFilter
    DependsOn: LambdaPermission
    Properties:
      LogGroupName: !Ref ECSLogGroup
      FilterPattern: ""
      DestinationArn: !GetAtt LogProcessorFunction.Arn

  # CloudWatch Dashboard for Logs
  LogsDashboard:
    Type: AWS::CloudWatch::Dashboard
    Condition: CreateDashboardCondition
    Properties:
      DashboardName: !Sub "${Environment}-logs-dashboard"
      DashboardBody: !Sub |
        {
          "widgets": [
            {
              "type": "text",
              "x": 0,
              "y": 0,
              "width": 24,
              "height": 2,
              "properties": {
                "markdown": "# Centralized Logging Dashboard\\nEnvironment: ${Environment}"
              }
            },
            {
              "type": "metric",
              "x": 0,
              "y": 2,
              "width": 12,
              "height": 6,
              "properties": {
                "metrics": [
                  [ "LogMetrics/${Environment}", "LambdaErrors" ],
                  [ ".", "API4xxErrors" ],
                  [ ".", "API5xxErrors" ]
                ],
                "period": 300,
                "stat": "Sum",
                "region": "${AWS::Region}",
                "title": "Error Metrics"
              }
            },
            {
              "type": "log",
              "x": 12,
              "y": 2,
              "width": 12,
              "height": 6,
              "properties": {
                "query": "SOURCE '/aws/centralized/${Environment}' | fields @timestamp, @message\\n| sort @timestamp desc\\n| filter @message like /ERROR/\\n| limit 20",
                "region": "${AWS::Region}",
                "title": "Recent Error Logs",
                "view": "table"
              }
            },
            {
              "type": "log",
              "x": 0,
              "y": 8,
              "width": 24,
              "height": 8,
              "properties": {
                "query": "SOURCE '/aws/centralized/${Environment}' | stats count(*) as logCount by sourceLogGroup, bin(30m)\\n| sort logCount desc",
                "region": "${AWS::Region}",
                "title": "Log Volume by Source",
                "view": "table"
              }
            },
            {
              "type": "log",
              "x": 0,
              "y": 16,
              "width": 24,
              "height": 8,
              "properties": {
                "query": "SOURCE '/aws/centralized/${Environment}' | fields @timestamp, sourceLogGroup, environment, enhancedTimestamp\\n| sort @timestamp desc\\n| limit 100",
                "region": "${AWS::Region}",
                "title": "Recent Logs",
                "view": "table"
              }
            }
          ]
        }

Conditions:
  CreateDashboardCondition: !Equals [!Ref CreateDashboard, 'true']

Outputs:
  CentralizedLogGroupName:
    Description: Name of the centralized log group
    Value: !Ref CentralizedLogGroup
  
  LogProcessorFunctionArn:
    Description: ARN of the log processor Lambda function
    Value: !GetAtt LogProcessorFunction.Arn
  
  LogsDashboardURL:
    Description: URL to the Logs Dashboard (if created)
    Condition: CreateDashboardCondition
    Value: !Sub "https://${AWS::Region}.console.aws.amazon.com/cloudwatch/home?region=${AWS::Region}#dashboards:name=${LogsDashboard}"
  
  DeadLetterQueueArn:
    Description: ARN of the Dead Letter Queue for failed log processing
    Value: !GetAtt LogProcessorDLQ.Arn
  
  DeadLetterQueueURL:
    Description: URL of the Dead Letter Queue for failed log processing
    Value: !Ref LogProcessorDLQ